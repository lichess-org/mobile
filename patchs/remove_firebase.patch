diff --git a/android/app/build.gradle.kts b/android/app/build.gradle.kts
index 3d87e06ec..75524e7db 100644
--- a/android/app/build.gradle.kts
+++ b/android/app/build.gradle.kts
@@ -6,8 +6,19 @@ plugins {
     id("kotlin-android")
     // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
     id("dev.flutter.flutter-gradle-plugin")
-    id("com.google.gms.google-services")
-    id("com.google.firebase.crashlytics")
+}
+
+configurations.all {
+    // Use the latest version published: https://central.sonatype.com/artifact/com.google.crypto.tink/tink-android
+    val tink = "com.google.crypto.tink:tink-android:1.17.0"
+    // You can also use the library declaration catalog
+    // val tink = libs.google.tink
+    resolutionStrategy {
+        force(tink)
+        dependencySubstitution {
+            substitute(module("com.google.crypto.tink:tink")).using(module(tink))
+        }
+    }
 }
 
 val keystoreProperties = Properties()
diff --git a/android/settings.gradle.kts b/android/settings.gradle.kts
index 952468b72..ab39a10a2 100644
--- a/android/settings.gradle.kts
+++ b/android/settings.gradle.kts
@@ -20,8 +20,6 @@ plugins {
     id("dev.flutter.flutter-plugin-loader") version "1.0.0"
     id("com.android.application") version "8.7.3" apply false
     id("org.jetbrains.kotlin.android") version "2.1.0" apply false
-    id("com.google.gms.google-services") version "4.4.0" apply false
-    id("com.google.firebase.crashlytics") version "2.9.9" apply false
 }
 
 include(":app")
diff --git a/lib/firebase_options.dart b/lib/firebase_options.dart
index 246b27938..e9fc12eb9 100644
--- a/lib/firebase_options.dart
+++ b/lib/firebase_options.dart
@@ -1,6 +1,6 @@
 // File generated by FlutterFire CLI.
 // ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
-import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
+import 'package:lichess_mobile/firebase_stubs.dart' show FirebaseOptions;
 import 'package:flutter/foundation.dart' show defaultTargetPlatform, kIsWeb, TargetPlatform;
 
 /// Default [FirebaseOptions] for use with your Firebase apps.
diff --git a/lib/src/binding.dart b/lib/src/binding.dart
index 5b9e7821c..1a8e63a94 100644
--- a/lib/src/binding.dart
+++ b/lib/src/binding.dart
@@ -1,9 +1,6 @@
-import 'package:firebase_core/firebase_core.dart';
-import 'package:firebase_crashlytics/firebase_crashlytics.dart';
-import 'package:firebase_messaging/firebase_messaging.dart';
 import 'package:flutter/foundation.dart';
 import 'package:flutter/widgets.dart';
-import 'package:lichess_mobile/firebase_options.dart';
+import 'package:lichess_mobile/firebase_stubs.dart';
 import 'package:lichess_mobile/src/log.dart';
 import 'package:lichess_mobile/src/model/engine/engine.dart';
 import 'package:shared_preferences/shared_preferences.dart';
diff --git a/lib/src/model/notifications/notification_service.dart b/lib/src/model/notifications/notification_service.dart
index 053551644..25a310a22 100644
--- a/lib/src/model/notifications/notification_service.dart
+++ b/lib/src/model/notifications/notification_service.dart
@@ -1,21 +1,18 @@
 import 'dart:async';
 import 'dart:convert';
 
-import 'package:firebase_messaging/firebase_messaging.dart';
-import 'package:flutter/foundation.dart';
 import 'package:flutter_local_notifications/flutter_local_notifications.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
 import 'package:lichess_mobile/l10n/l10n.dart';
 import 'package:lichess_mobile/src/binding.dart';
+import 'package:lichess_mobile/src/constants.dart';
 import 'package:lichess_mobile/src/localizations.dart';
-import 'package:lichess_mobile/src/model/auth/auth_session.dart';
-import 'package:lichess_mobile/src/model/common/preloaded_data.dart';
 import 'package:lichess_mobile/src/model/notifications/notifications.dart';
 import 'package:lichess_mobile/src/network/connectivity.dart';
 import 'package:lichess_mobile/src/network/http.dart';
-import 'package:lichess_mobile/src/utils/badge_service.dart';
 import 'package:logging/logging.dart';
 import 'package:riverpod_annotation/riverpod_annotation.dart';
+import 'package:unifiedpush/unifiedpush.dart';
 
 part 'notification_service.g.dart';
 
@@ -81,9 +78,6 @@ class NotificationService {
   /// The stream subscription for notification responses.
   StreamSubscription<NotificationResponse>? _responseStreamSubscription;
 
-  /// Whether the device has been registered for push notifications.
-  bool _registeredDevice = false;
-
   AppLocalizations get _l10n => _ref.read(localizationsProvider).strings;
 
   FlutterLocalNotificationsPlugin get _notificationDisplay =>
@@ -97,59 +91,68 @@ class NotificationService {
   ///
   /// This method should be called once the app is ready to receive notifications,
   /// and after [LichessBinding.initializeNotifications] has been called.
-  Future<void> start() async {
-    // listen for connectivity changes to register device once the app is online
-    _connectivitySubscription = _ref.listen(connectivityChangesProvider, (prev, current) async {
-      if (current.value?.isOnline == true && !_registeredDevice) {
-        try {
-          await registerDevice();
-          _registeredDevice = true;
-        } catch (e, st) {
-          _logger.severe('Could not setup push notifications; $e\n$st');
-        }
+  Future<void> start() {
+    return UnifiedPush.initialize(
+      onNewEndpoint: onNewEndpoint,
+      onRegistrationFailed: onRegistrationFailed,
+      onUnregistered: onUnregistered,
+      onMessage: onMessage,
+    ).then((registered) {
+      if (registered) {
+        UnifiedPush.register(vapid: kLichessVapidPublicKey);
       }
     });
+  }
 
-    // Listen for incoming messages while the app is in the foreground.
-    LichessBinding.instance.firebaseMessagingOnMessage.listen((RemoteMessage message) {
-      _processFcmMessage(message, fromBackground: false);
-    });
-
-    // Listen for incoming messages while the app is in the background.
-    LichessBinding.instance.firebaseMessagingOnBackgroundMessage(
-      _firebaseMessagingBackgroundHandler,
-    );
-
-    // Request permission to receive notifications. Pop-up will appear only
-    // once.
-    await LichessBinding.instance.firebaseMessaging.requestPermission(
-      alert: true,
-      badge: true,
-      sound: true,
-      announcement: false,
-      carPlay: false,
-      criticalAlert: false,
-      provisional: false,
-    );
+  void onNewEndpoint(PushEndpoint endpoint, String instance) {
+    if (endpoint.pubKeySet == null) {
+      _logger.warning('no public key found');
+      return;
+    }
 
-    // Listen for token refresh and update the token on the server accordingly.
-    _fcmTokenRefreshSubscription = LichessBinding.instance.firebaseMessaging.onTokenRefresh.listen((
-      String token,
-    ) {
-      _registerToken(token);
-    });
+    final body = {
+      'endpoint': endpoint.url,
+      'keys': {'auth': endpoint.pubKeySet!.auth, 'p256dh': endpoint.pubKeySet!.pubKey},
+    };
+
+    _ref
+        .withClient(
+          (client) => client.post(
+            Uri(path: '/push/subscribe'),
+            body: jsonEncode(body),
+            headers: {'Content-Type': 'application/json'},
+          ),
+        )
+        .then((response) {
+          final statusCode = response.statusCode;
+          if (200 <= statusCode && statusCode < 300) {
+            _logger.info('new endpoint sent succesfully');
+          } else {
+            _logger.warning('new endpoint sent but request failed with status code $statusCode');
+          }
+        })
+        .catchError((Object err) {
+          _logger.warning('sending new endpoint failed with error $err');
+        });
+  }
 
-    // Get any messages which caused the application to open from
-    // a terminated state.
-    final RemoteMessage? initialMessage = await LichessBinding.instance.firebaseMessaging
-        .getInitialMessage();
+  void onRegistrationFailed(FailedReason reason, String instance) {
+    _logger.warning('registration failed for reason: $reason');
+  }
 
-    if (initialMessage != null) {
-      _handleFcmMessageOpenedApp(initialMessage);
-    }
+  void onUnregistered(String instance) {
+    _logger.info('device unregistered');
+  }
 
-    // Handle any other interaction that caused the app to open when in background.
-    LichessBinding.instance.firebaseMessagingOnMessageOpenedApp.listen(_handleFcmMessageOpenedApp);
+  void onMessage(PushMessage message, String instance) {
+    final content = jsonDecode(utf8.decode(message.content)) as Map<String, dynamic>;
+    final channel = content['tag'] as String;
+    _notificationDisplay.show(
+      0,
+      content['title'] as String,
+      content['body'] as String,
+      NotificationDetails(android: AndroidNotificationDetails(channel, channel)),
+    );
   }
 
   /// Shows a notification.
@@ -200,146 +203,21 @@ class NotificationService {
     _responseStreamController.add((response, notification));
   }
 
-  /// Handle an FCM message that caused the application to open
-  void _handleFcmMessageOpenedApp(RemoteMessage message) {
-    final parsedMessage = FcmMessage.fromRemoteMessage(message);
-
-    switch (parsedMessage) {
-      case final CorresGameUpdateFcmMessage corresMessage:
-        final notification = CorresGameUpdateNotification.fromFcmMessage(corresMessage);
-        _responseStreamController.add((
-          NotificationResponse(
-            notificationResponseType: NotificationResponseType.selectedNotification,
-            id: notification.id,
-            payload: jsonEncode(notification.payload),
-          ),
-          notification,
-        ));
-
-      // TODO: handle other notification types
-      case UnhandledFcmMessage(data: final data):
-        _logger.warning('Received unhandled FCM notification type: ${data['lichess.type']}');
-
-      case MalformedFcmMessage(data: final data):
-        _logger.severe('Received malformed FCM message: $data');
-    }
-  }
-
-  /// Process a message received from the Firebase Cloud Messaging service.
-  ///
-  /// If the message contains a [RemoteMessage.notification] field and if it is
-  /// received while the app was in foreground, the notification is by default not
-  /// shown to the user.
-  /// Depending on the message type, we may as well show a local notification.
-  ///
-  /// Some messages (whether or not they have an associated notification), have
-  /// a [RemoteMessage.data] field used to update the application state according
-  /// to the message type.
-  ///
-  /// A special data field, 'lichess.iosBadge', is used to update the iOS app's
-  /// badge count according to the value held by the server.
-  Future<void> _processFcmMessage(
-    RemoteMessage message, {
-
-    /// Whether the message was received while the app was in the background.
-    required bool fromBackground,
-  }) async {
-    _logger.fine(
-      'Processing a FCM message from ${fromBackground ? 'background' : 'foreground'}: ${message.data}',
-    );
-
-    final parsedMessage = FcmMessage.fromRemoteMessage(message);
-
-    _fcmMessageStreamController.add((message: parsedMessage, fromBackground: fromBackground));
-
-    switch (parsedMessage) {
-      case CorresGameUpdateFcmMessage(fullId: final fullId, notification: final notification):
-        if (fromBackground == false && notification != null) {
-          await show(CorresGameUpdateNotification(fullId, notification.title!, notification.body!));
-        }
-
-      // TODO: handle other notification types
-
-      case UnhandledFcmMessage(data: final data):
-        _logger.warning('Received unhandled FCM notification type: ${data['lichess.type']}');
-
-      case MalformedFcmMessage(data: final data):
-        _logger.severe('Received malformed FCM message: $data');
-    }
-
-    // update badge
-    final badge = message.data['lichess.iosBadge'] as String?;
-    if (badge != null) {
-      try {
-        await BadgeService.instance.setBadge(int.parse(badge));
-      } catch (e) {
-        _logger.severe('Could not parse badge: $badge');
-      }
-    }
-  }
-
   /// Register the device for push notifications.
-  Future<void> registerDevice() async {
-    if (defaultTargetPlatform == TargetPlatform.iOS) {
-      final apnsToken = await LichessBinding.instance.firebaseMessaging.getAPNSToken();
-      if (apnsToken == null) {
-        _logger.warning('APNS token is null');
-        return;
+  Future<void> registerDevice() {
+    _logger.info('register device for the first time');
+    return UnifiedPush.tryUseCurrentOrDefaultDistributor().then((success) {
+      if (success) {
+        UnifiedPush.register(vapid: kLichessVapidPublicKey);
+      } else {
+        _logger.info('could not find a distributor');
       }
-    }
-    final token = await LichessBinding.instance.firebaseMessaging.getToken();
-    if (token != null) {
-      await _registerToken(token);
-    }
+    });
   }
 
   /// Unregister the device from push notifications.
-  Future<void> unregister() async {
+  Future<void> unregister() {
     _logger.info('will unregister');
-    final session = _ref.read(authSessionProvider);
-    if (session == null) {
-      return;
-    }
-    try {
-      await _ref.withClient((client) => client.post(Uri(path: '/mobile/unregister')));
-    } catch (e, st) {
-      _logger.severe('could not unregister device; $e', e, st);
-    }
-  }
-
-  Future<void> _registerToken(String token) async {
-    final settings = await LichessBinding.instance.firebaseMessaging.getNotificationSettings();
-    if (settings.authorizationStatus == AuthorizationStatus.denied) {
-      return;
-    }
-    _logger.info('will register fcmToken: $token');
-    final session = _ref.read(authSessionProvider);
-    if (session == null) {
-      return;
-    }
-    try {
-      await _ref.withClient((client) => client.post(Uri(path: '/mobile/register/firebase/$token')));
-    } catch (e, st) {
-      _logger.severe('could not register device; $e', e, st);
-    }
-  }
-
-  @pragma('vm:entry-point')
-  static Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
-    // create a new provider scope for the background isolate
-    final ref = ProviderContainer();
-
-    final lichessBinding = AppLichessBinding.ensureInitialized();
-    await lichessBinding.preloadSharedPreferences();
-    await ref.read(preloadedDataProvider.future);
-
-    try {
-      await ref.read(notificationServiceProvider)._processFcmMessage(message, fromBackground: true);
-
-      ref.dispose();
-    } catch (e) {
-      _logger.severe('Error when processing an FCM background message: $e');
-      ref.dispose();
-    }
+    return UnifiedPush.unregister();
   }
 }
diff --git a/lib/src/model/notifications/notifications.dart b/lib/src/model/notifications/notifications.dart
index acc4fba56..848eecca3 100644
--- a/lib/src/model/notifications/notifications.dart
+++ b/lib/src/model/notifications/notifications.dart
@@ -1,8 +1,8 @@
 import 'dart:convert';
 
 import 'package:deep_pick/deep_pick.dart';
-import 'package:firebase_messaging/firebase_messaging.dart';
 import 'package:flutter_local_notifications/flutter_local_notifications.dart';
+import 'package:lichess_mobile/firebase_stubs.dart';
 import 'package:lichess_mobile/l10n/l10n.dart';
 import 'package:lichess_mobile/src/model/challenge/challenge.dart';
 import 'package:lichess_mobile/src/model/common/id.dart';
diff --git a/pubspec.yaml b/pubspec.yaml
index e06d4cd61..7f5953c8e 100644
--- a/pubspec.yaml
+++ b/pubspec.yaml
@@ -27,9 +27,6 @@ dependencies:
   device_info_plus: ^11.0.0
   dynamic_system_colors: ^1.8.0
   fast_immutable_collections: ^11.0.0
-  firebase_core: ^3.0.0
-  firebase_crashlytics: ^4.0.0
-  firebase_messaging: ^15.0.0
   fl_chart: ^1.0.0
   flutter:
     sdk: flutter
@@ -71,6 +68,7 @@ dependencies:
   sound_effect: ^0.1.1
   sqflite: ^2.2.5
   stream_transform: ^2.1.0
+  unifiedpush: ^6.0.2
   url_launcher: ^6.1.9
   visibility_detector: ^0.4.0
   wakelock_plus: ^1.1.1
